# Лабораторная работа №5

**Выполнил:** Попков Максим Александрович, М8О-105БВ-25  
**Тема:** Отладка кодовой базы проекта на Python с помощью средств отладки



## Цель работы

- закрепление навыков работы с отладчиком;
- формирование понимания типовых логических и runtime-ошибок;
- освоение методики поиска, анализа и устранения ошибок;
- развитие умения объяснять причину некорректного поведения программы.



## Ошибка 1 — изменение коллекции при итерации

**Место:** `simulation.py`, функция `run_simulation`, вспомогательная `_remove`

**Симптом:**  
вместо удаления одной случайной книги удаляются все. В сценарии `run_simulation(steps=50, seed=1)`  
после шага 32 в библиотеке 4 книги, на шаге 33 выполняется `REMOVE` и библиотека опустошается;  
аналогично после шага 47. При этом в логах показывается только последний удаленный объект, из-за  
этого несоответствие с фактическим состоянием.

**Как воспроизвести:**  
запустить `run_simulation(steps=50, seed=1)`; проверить размер коллекции перед и после события  
`REMOVE` (например, вотч `len(library)` или `list(library)` в отладчике) – падает до 0 за одно событие.

**Отладка:**  
breakpoint на строке `for b in library:`. В `Locals` видно, что цикл идёт по текущей коллекции, на каждой  
итерации вызывается `library.remove_book(b)`, коллекция уменьшается, в итоге удаляются все  
элементы; переменная `b` после цикла – только последний удалённый, именно его и логирует.

**Причина:**  
модификация коллекции, по которой идёт итерация: удаление в `for b in library` приводит к тому, что за  
одно событие удаляются все элементы, а лог вводит в заблуждение, показывая только последний.

**Исправление:**  
не менять коллекцию, по которой итерируешься: выбрать один случайный элемент из копии  
(`book = random.choice(list(library))`), удалить его и логировать; либо итерироваться по копии, если нужно  
удалить несколько, и логировать каждый.

**Проверка:**  
после фикса при том же `seed=1` событие `REMOVE` уменьшает размер библиотеки на 1 (было 4 →  
стало 3 после шага 33, и т.д.), лог соответствует фактическому состоянию.

**Доказательства:**  
До исправления:  
`img/img1.png`  
`img/img2.png`  
`img/img3.png`  
`img/img4.png`  
`img/img5.png`  
После исправления:  
`img/img6.png`  
`img/img7.png`  
`img/img8.png`
`img/img9.png`



## Ошибка 2 — ошибка границы цикла (off-by-one)

**Место:** `simulation.py`, функция `run_simulation`

**Симптом:**  
при заданных `steps` выполняется на один шаг больше событий, чем ожидается (для 12 шагов  
исполняется 13).

**Как воспроизвести:**  
запустить `run_simulation(steps=12, seed=1)` под отладчиком или просто посмотреть лог – видно на  
один шаг больше записей.

**Отладка:**  
breakpoint на строке цикла. В `Locals` на последней итерации `steps=12`, `step=12`, хотя должно быть  
максимум 11.

**Причина:**  
ошибка границы цикла (off-by-one) – используется `range(steps + 1)` вместо `range(steps)`.

**Исправление:**  
заменить строку на `for step in range(steps):`

**Проверка:**  
после фикса `step` проходит `0..11` при `steps=12`, количество событий в логе совпадает с 12, итоговое  
состояние библиотеки соответствует ожиданию.

**Доказательства:**  
До исправления:  
`img/img10.png`  
`img/img11.png`  
`img/img12.png`  
После исправления:  
`img/img13.png`  
`img/img14.png`  
`img/img15.png`  



## Ошибка 3 — неверное условие поиска жанра (find by genre)

**Место:** `library.py`, метод `find_by_genre`

**Симптом:**  
поиск по жанру всегда возвращает пустой список, даже если книги с таким жанром есть.

**Как воспроизвести:**  
`run_simulation(steps=12, seed=1)`; в логах видно, что на 9 шаге добавляется книга жанра «история», на  
11 шаге вызов `FIND_BY_GENRE «история»` выдает пустой список.

**Отладка:**  
breakpoint на условии в `find_by_genre`. В `Locals` при вызове: `genre="история"`, `book.genre="история"`,  
но сравнение идёт с `genre.upper()` – условие `False`, список не заполняется.

**Причина:**  
неверное логическое условие — сравнение в разных регистрах (`book.genre` в lower, `genre.upper()` в  
upper).

**Исправление:**  
сравнивать в одном регистре: `genre = genre.strip().lower()` и `if book.genre == genre:`

**Проверка:**  
после фикса повторный запуск `run_simulation(steps=12, seed=1)` даёт непустой результат для  
`FIND_BY_GENRE «история»`; локально `library.find_by_genre("история")` возвращает книгу.

**Доказательства:**  
До исправления:  
`img/img16.png`  
`img/img17.png`  
`img/img18.png` 

Перешли к следующей книге, res по-прежнему пустой:  
`img/img19.png` 

После исправления:  
`img/img20.png`
`img/img21.png`
`img/img22.png`



## Ошибка 4 — mutable default

**Место:** `collections.py`, конструктор `BookCollection.__init__`

**Симптом:**  
разные экземпляры `BookCollection` делятся книгами: добавление в один появляется в другом.

**Как воспроизвести:**  
в Debug Console: создать `c1 = BookCollection()` и `c2 = BookCollection()`, добавить книгу в `c1`, затем  
проверить `len(c2)` – станет 1.

**Отладка:**  
```python
from src.collections import BookCollection
from src.models import Book
b = Book("title","author",2020,"genge","isbn")
c1 = BookCollection()
c2 = BookCollection()
c1.add_book(b)
print(len(c1), len(c2), id(c1._books), id(c2._books))
```

Видно одинаковые `len` и одинаковые `id` списка.

**Причина:**  
использовано изменяемое значение по умолчанию (общий список для всех экземпляров).

**Исправление:**  
вернуть сигнатуру `books: list[Book] | None = None`, внутри создавать новый список.

**Проверка:**  
после фикса `len(c2)` остаётся 0, `id` разных списков отличаются.

**Доказательства:**  
До исправления:  
`img/img23.png`  
`img/img24.png` 

После исправления:  
`img/img25.png`  
`img/img26.png` 



## Ошибка 5 — сравнение через is вместо ==

**Место:** `models.py`, метод `Book.__eq__`

**Симптом:**  
два разных объекта `Book` с одинаковыми данными сравниваются как неравные (`False`).

**Как воспроизвести:**  
```python
from src.models import Book
b1 = Book("Title 123456", "Author 123456", 2020, "genre", "123-456")
b2 = Book("Title " + "123456", "Author " + "123456", 2020, "genre", "123-456")
print(b1 == b2)
```

Результат `False`.

**Отладка:**  
breakpoint в `__eq__` и сравнить `Locals`: поля одинаковые, но `is` даёт `False`, потому что это разные  
объекты строк.

**Причина:**  
используется сравнение идентичности (`is`) вместо равенства (`==`) для строк/чисел.

**Исправление:**  
заменить все `is` на `==` в `__eq__`.

**Проверка:**  
после фикса тот же тест возвращает `True`.

**Доказательства:**  
До исправления:  
`img/img27.png`  
`img/img28.png`  
`img/img29.png`  

После исправления:  
`img/img30.png`  
`img/img31.png`  


## Вывод

За время работы выявил и исправил пять логических/runtime-ошибок: off-by-one в цикле симуляции,  
неверное сравнение жанра, удаление элементов при итерации по той же коллекции, изменяемое  
значение по умолчанию в `BookCollection`, сравнение строк через `is` в `__eq__`. Каждую ошибку  
воспроизвёл (фиксированные seed, точки останова), зафиксировал причину и исправление,  
подтвердил корректность повторным запуском симуляции/проверкой состояния коллекций. Итог:  
поведение симуляции и поисков соответствует ожиданию, коллекции и сравнение объектов работают  
корректно, набор типовых багов устранён.
